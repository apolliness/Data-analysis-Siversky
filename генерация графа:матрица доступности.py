# -*- coding: utf-8 -*-
"""Сиверское_практика 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1k5T3NRELMlG0gN6uyM2IrPSN58DeP7XW

### Подготовка
"""

!pip install blocksnet iduedu mapclassify -qq

import geopandas as gpd
import os

data_path = '/content/data'

blocks = gpd.read_file(os.path.join(data_path, 'block.geojson')) # считываем в переменную наши кварталы

"""### Сборка дорожного графа

Импортируем метод ```get_boundary``` из IduEdu для получения геометрии города, для которого хотим собрать дорожный граф.
"""

import geopandas as gpd

bounds = gpd.read_file('/content/data/city.geojson')

"""Импортируем метод ```get_drive_graph``` для скачивания дорожного графа по полигону."""

from iduedu import get_drive_graph

G_drive = get_drive_graph(polygon=bounds.unary_union, additional_edgedata=['highway', 'maxspeed', 'reg', 'ref','name'])

"""В функцию ```get_drive_graph``` можно передать аргумент ```additional_edgedata``` для получения дополнительной информации о скачиваемых дорогах:

* ```highway``` – описание важности дороги в дорожной сети, подробнее [тут](https://wiki.openstreetmap.org/wiki/RU:Key:highway);

* ```maxspeed``` – максимально разрешённая скорость в км/ч, подробнее [тут](https://wiki.openstreetmap.org/wiki/RU:Key:maxspeed);

* ```reg``` – регистрационный статус дороги (1 – дорога федерального значения; 2 – дорога регионального значения; 3 – дорога местного значения);

* ```ref``` – используется для ссылочных номеров или кодов, подробнее [тут](https://wiki.openstreetmap.org/wiki/RU:Key:ref?uselang=ru);

* ```name``` – название дороги (если есть на OSM).
"""

G_drive # в этой переменной хранится собранный граф

from blocksnet import AccessibilityProcessor
AccessibilityProcessor._fix_graph(G_drive) # необходимо для исправления графа, запустить!

"""Импортируем доп. библиотеки для визуализации графа."""

import osmnx as ox
import matplotlib.pyplot as plt

fig, ax = ox.plot_graph(G_drive,
                    node_color='black', # цвет вершин
                    edge_color='grey', # цвет ребер
                    bgcolor='white', # цвет подложки
                    node_size=2, # размер верщин
                    edge_linewidth=2, # толщина ребер
                    figsize=(25,25)) # размер картинки

"""Сохраняем полученный результат в png файл."""

fig.savefig(os.path.join(data_path,'drive_graph_image.png'))

"""Для того чтобы посмотреть какая информация у нас есть о собранных дорогах, переведем граф в два ```GeoDataFrame```’а."""

n,e = ox.graph_to_gdfs(G_drive)

"""```GeoDataFrame``` с вершинами дорожного графа (нодами, ```n``` – сокр. nodes).



"""

n

"""```GeoDataFrame``` с ребрами дорожного графа (эджи, ```e``` – сокр. edges).

Колонка ```time_min``` содержит в себе значения времени в минутах, за которое можно проехать на автомобиле данный участок дороги.
"""

e

"""Сохраняем вершины и ребра графа в файлы GeoJSON."""

n.to_file(os.path.join(data_path,"G_drive_nodes.geojson"))

e.to_file(os.path.join(data_path,"G_drive_edges.geojson"))

"""### Создание матрицы доступности и квартально-сетевой модели + вычисление транспортной доступности и связности

Импортируем из BlocksNet класс ```AccessibilityProcessor```, необходимый для вычисления матрицы доступности по кварталам.

Создаем экземпляр класса в переменной ```ap``` и передаем туда кварталы ```blocks```.
"""

blocks.to_crs(32636, inplace=True)

from blocksnet import AccessibilityProcessor

ap = AccessibilityProcessor(blocks)

"""Вызываем метод ```get_accessibility_matrix``` у экземпляра ```ap```, передавая дорожный граф. Переменная ```acc_mx``` будет содержать матрицу доступности."""

acc_mx = ap.get_accessibility_matrix(G_drive)
acc_mx.head() # вывод первых 5 строк полученной матрицы

"""Сохраняем матрицу доступности в pickle файл."""

acc_mx.to_pickle(os.path.join(data_path, 'acc_mx.pickle'))

"""Импортируем из ```blocksnet.models``` класс ```City```."""

from blocksnet.models import City

"""Для создания квартально-сетевой модели города используются кварталы и матрица доступности. Чтобы модель собралась с учетом валидации данных, которая встроена в класс ```City```, необходимо добавить в кварталы информацию о зонировании территорий (землепользование). В случае если таких данных нет, то нужно добавить дополнительную колонку ```land_use``` с значениями ```None``` в ГеоДатаФрейм с кварталми."""

blocks['land_use'] = None

"""Создаем экземпляр класса в переменную ```city``` и отдаем туда кварталы и матрицу доступности."""

city = City(
    blocks=blocks,
    acc_mx=acc_mx
)

"""Вывод основной информации о собранной модели: CRS, кол-во кварталов, типов сервисов, зданий и сервисов."""

print(city)

"""Сохраняем модельку в pickle файл. Она вам пригодится на следующем практическом занятии :)"""

city.to_pickle(os.path.join(data_path,'city_model.pickle'))

"""Импортируем классы ```Accessibility``` и ```Connectivity``` для вычисления доступности и связности."""

from blocksnet import Accessibility, Connectivity

"""Создаем экземпляр класса в ```accessibility``` и передаем туда собранную модель. Вызываем метод ```calculate``` у экземпляра, передавая выбранный квартал. Метод рассчитывает доступность для данного квартала и сохраняет результат в переменной ```result```."""

accessibility = Accessibility(city_model=city)
block = city[60] # квартал от которого будем считать доступность
result = accessibility.calculate(block)

"""Визуализируем результат:"""

Accessibility.plot(result, linewidth=0.9, figsize=(30,15))

"""Сохраняем результат в файл GeoJSON."""

result.to_file(os.path.join(data_path, 'accessibility.geojson'))

"""Для вычисления связности: создаем экземпляр класса в ```connectivity``` и передаем туда собранную модель. Вызываем метод ```calculate``` у экземпляра в переменную ```connectivity_result```."""

connectivity = Connectivity(city_model=city)
connectivity_result = connectivity.calculate()

"""Визуализируем результат:"""

Connectivity.plot(connectivity_result, linewidth=0.9, figsize=(30,15))

"""Сохраняем результат в файл GeoJSON."""

connectivity_result.to_file(os.path.join(data_path, 'connectivity.geojson'))